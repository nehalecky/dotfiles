#!/usr/bin/env python3
"""
Enhanced Weather Display for Terminal
Uses precise location detection and Rich formatting

Future TUI App Foundation:
- Modular weather data fetching
- Rich-based formatting components  
- Extensible emoji/formatting system
- Clean separation of data/display logic
"""

import json
import subprocess
import sys
from datetime import datetime
from typing import Dict, Optional, Tuple
from urllib.request import urlopen
from urllib.parse import quote

# Graceful dependency handling for future TUI development
def check_dependencies():
    """Check and suggest dependency installation"""
    missing = []
    try:
        from rich.console import Console
        from rich.text import Text
    except ImportError:
        missing.append("rich")
        
    if missing:
        print(f"üêç Missing packages: {', '.join(missing)}")
        print("üí° Install with UV:")
        print(f"   uv run --with {' --with '.join(missing)} {sys.argv[0]}")
        print("üöÄ Or for development: python3 -m pip install --user --break-system-packages " + " ".join(missing))
        print("üìö Learning UV: https://docs.astral.sh/uv/")
        return False
    return True

if not check_dependencies():
    sys.exit(1)

from rich.console import Console
from rich.text import Text

# Country code to flag emoji (no external dependency needed!)
def country_to_flag(country_code: str) -> str:
    """Convert country code to flag emoji using Unicode math"""
    if len(country_code) != 2:
        return "üåç"
    return "".join(chr(ord(c) + 127397) for c in country_code.upper())

console = Console()

# =============================================================================
# FUTURE TUI APP FOUNDATIONS
# =============================================================================
# This script is designed as a foundation for a full TUI weather app
# 
# TUI App Architecture Ideas:
# 1. Main Dashboard: Current + 7-day forecast with Rich tables
# 2. Location Manager: Add/remove favorite locations
# 3. Settings Panel: Units, refresh rate, emoji themes
# 4. Detail Views: Hourly breakdown, weather maps, alerts
# 5. Keyboard Navigation: vim-like keybinds for power users
# 
# Rich Components to explore:
# - rich.table.Table for forecast grids
# - rich.progress.Progress for loading weather data
# - rich.layout.Layout for responsive panels  
# - rich.live.Live for real-time updates
# - rich.panel.Panel for grouped weather info
# - rich.console.Group for complex layouts
# =============================================================================

# Weather condition to emoji mapping (TUI app will have theme support)
WEATHER_EMOJI = {
    # Clear conditions
    "Clear": "‚òÄÔ∏è", "Sunny": "‚òÄÔ∏è", "Fair": "‚òÄÔ∏è",
    
    # Partly cloudy variations  
    "Partly cloudy": "üå§Ô∏è", "Partly Cloudy": "üå§Ô∏è", "Partly cloudy ": "üå§Ô∏è",
    
    # Mostly cloudy
    "Mostly cloudy": "üå•Ô∏è", "Mostly Cloudy": "üå•Ô∏è",
    
    # Cloudy conditions
    "Cloudy": "‚òÅÔ∏è", "Cloudy ": "‚òÅÔ∏è", "Overcast": "‚òÅÔ∏è",
    
    # Rain conditions  
    "Light rain": "üå¶Ô∏è", "Light Rain": "üå¶Ô∏è",
    "Rain": "üåßÔ∏è", "Heavy rain": "üåßÔ∏è", "Heavy Rain": "üåßÔ∏è",
    "Moderate rain": "üåßÔ∏è", "Heavy shower": "üåßÔ∏è",
    
    # Snow conditions
    "Light snow": "‚ùÑÔ∏è", "Snow": "üå®Ô∏è", "Heavy snow": "üå®Ô∏è",
    "Light snow shower": "‚ùÑÔ∏è", "Moderate snow": "üå®Ô∏è",
    
    # Storms
    "Thunderstorm": "‚õàÔ∏è", "Storm": "‚õàÔ∏è", "Thundery shower": "‚õàÔ∏è",
    "Lightning": "üå©Ô∏è", "Thunder": "‚õàÔ∏è",
    
    # Fog and mist
    "Fog": "üå´Ô∏è", "Mist": "üå´Ô∏è", "Hazy": "üå´Ô∏è",
    
    # Light precipitation
    "Drizzle": "üå¶Ô∏è", "Showers": "üåßÔ∏è", "Light shower": "üå¶Ô∏è"
}

def get_weather_emoji(condition: str) -> str:
    """Convert weather condition to emoji"""
    # Strip whitespace and normalize condition string
    clean_condition = condition.strip()
    return WEATHER_EMOJI.get(clean_condition, "üåç")

def get_precise_location() -> Tuple[Optional[str], Optional[str]]:
    """Get precise location using CoreLocationCLI"""
    try:
        result = subprocess.run(
            ["CoreLocationCLI", "-format", "%latitude,%longitude"], 
            capture_output=True, text=True, timeout=5
        )
        if result.returncode == 0:
            coords = result.stdout.strip()
            if coords and coords != ",":
                return coords, None
    except (subprocess.TimeoutExpired, subprocess.SubprocessError, FileNotFoundError):
        pass
    return None, "Location detection failed"

def fetch_weather_data(coords: str) -> Optional[Dict]:
    """Fetch comprehensive weather data from wttr.in (foundation for future TUI app)"""
    try:
        url = f"https://wttr.in/{quote(coords)}?format=j1"
        with urlopen(url, timeout=10) as response:
            return json.loads(response.read().decode('utf-8'))
    except (Exception,):  # Broad catch for network/JSON errors
        return None

def format_location_line(weather_data: Dict, coords: str) -> Text:
    """Format line 1: Location with flag and current conditions"""
    current = weather_data.get("current_condition", [{}])[0]
    location = weather_data.get("nearest_area", [{}])[0]
    
    # Extract location details
    area_name = location.get("areaName", [{}])[0].get("value", "Unknown")
    country = location.get("country", [{}])[0].get("value", "Unknown")
    country_code = location.get("country", [{}])[0].get("value", "")
    
    # Smart country code detection for flag (TUI app will expand this)
    country_flag = ""
    if len(country) == 2:  # Already a country code
        country_flag = country_to_flag(country.upper())
    else:
        # Map common country names to codes (future TUI will have full mapping)
        country_map = {
            "Argentina": "AR", "United States": "US", "Chile": "CL",
            "Canada": "CA", "United Kingdom": "GB", "France": "FR",
            "Germany": "DE", "Japan": "JP", "Australia": "AU"
        }
        for name, code in country_map.items():
            if name in country:
                country_flag = country_to_flag(code)
                break
        if not country_flag:
            country_flag = "üåç"
    
    # Current conditions
    temp = current.get("temp_C", "?")
    feels_like = current.get("FeelsLikeC", "?")
    condition = current.get("weatherDesc", [{}])[0].get("value", "Unknown")
    humidity = current.get("humidity", "?")
    wind_speed = current.get("windspeedKmph", "?")
    wind_dir = current.get("winddir16Point", "")
    
    # Wind direction arrow
    wind_arrows = {
        "N": "‚Üë", "NNE": "‚Üó", "NE": "‚Üó", "ENE": "‚Üí", "E": "‚Üí",
        "ESE": "‚Üò", "SE": "‚Üò", "SSE": "‚Üì", "S": "‚Üì", "SSW": "‚Üô",
        "SW": "‚Üô", "WSW": "‚Üê", "W": "‚Üê", "WNW": "‚Üñ", "NW": "‚Üñ", "NNW": "‚Üë"
    }
    wind_arrow = wind_arrows.get(wind_dir, "")
    
    emoji = get_weather_emoji(condition)
    
    text = Text()
    text.append("üìç ", style="blue")
    text.append(f"{area_name}", style="cyan bold")
    text.append(f" ({coords}) ", style="dim")
    text.append(f"{country_flag} ", style="bright_yellow")
    text.append("| Current: ", style="white")
    text.append(f"{emoji} {temp}¬∞C", style="red bold")
    text.append(f" (feels {feels_like}¬∞C)", style="yellow")
    text.append(f" | {humidity}% ", style="blue")
    text.append(f"{wind_arrow} {wind_speed}km/h", style="green")
    
    return text

def format_hourly_line(weather_data: Dict) -> Text:
    """Format line 2: Next 24 hours in 3-hour increments with precipitation"""
    hourly = weather_data.get("weather", [{}])[0].get("hourly", [])
    
    text = Text()
    text.append("‚è∞ Next 24h: ", style="magenta")
    
    # Key 3-hour intervals: 6AM, 12PM, 6PM, 12AM  
    time_slots = [
        (2, "6AM"), (4, "12PM"), (6, "6PM"), (0, "12AM")
    ]
    
    for i, (idx, label) in enumerate(time_slots):
        if idx < len(hourly):
            hour_data = hourly[idx]
            temp = hour_data.get("tempC", "?")
            condition = hour_data.get("weatherDesc", [{}])[0].get("value", "")
            precip = hour_data.get("precipMM", "0")
            
            emoji = get_weather_emoji(condition)
            
            if i > 0:
                text.append(" | ", style="dim")
            text.append(f"{label} ", style="bright_cyan")
            text.append(f"{emoji} ", style="yellow")
            text.append(f"{temp}¬∞C", style="red")
            
            # Add precipitation if > 0
            if float(precip) > 0:
                text.append(f" ({precip}mm)", style="blue")
    
    return text

def format_daily_line(weather_data: Dict) -> Text:
    """Format line 3: 3-day forecast with precipitation (wttr.in limitation)"""
    weather_days = weather_data.get("weather", [])
    
    text = Text()
    text.append("üìÖ 3-Day: ", style="green")
    
    days = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
    today = datetime.now().weekday()  # 0 = Monday
    
    for i in range(len(weather_days)):  # Show all available days (typically 3)
        if i > 0:
            text.append(" ", style="dim")
            
        day_data = weather_days[i]
        day_name = days[(today + i) % 7]
        max_temp = day_data.get("maxtempC", "?")
        min_temp = day_data.get("mintempC", "?")
        
        # Get total precipitation for the day
        total_precip = day_data.get("totalPrecipMM", "0")
        
        # Use condition from middle of day (around noon)
        hourly = day_data.get("hourly", [])
        condition = ""
        if len(hourly) >= 4:
            condition = hourly[4].get("weatherDesc", [{}])[0].get("value", "")
        
        emoji = get_weather_emoji(condition)
        
        text.append(f"{day_name} ", style="cyan")
        text.append(f"{emoji} ", style="yellow")
        text.append(f"{max_temp}¬∞", style="red bold")
        text.append("/", style="dim")
        text.append(f"{min_temp}¬∞", style="blue")
        
        # Add precipitation if > 0
        if float(total_precip) > 0:
            text.append(f" ({total_precip}mm)", style="blue")
    
    return text

def main():
    """Main weather display function"""
    # Get precise location
    coords, error = get_precise_location()
    if error:
        console.print(f"‚ùå {error}", style="red")
        console.print("üåç Using IP-based location...", style="yellow")
        coords = ""  # Fallback to IP detection
    
    # Fetch weather data
    weather_data = fetch_weather_data(coords)
    if not weather_data:
        console.print("‚ùå Failed to fetch weather data", style="red")
        return
    
    # Format and display 3 lines
    try:
        line1 = format_location_line(weather_data, coords or "Auto-detected")
        line2 = format_hourly_line(weather_data)
        line3 = format_daily_line(weather_data)
        
        console.print(line1)
        console.print(line2) 
        console.print(line3)
        
    except Exception as e:
        console.print(f"‚ùå Format error: {e}", style="red")
        # Fallback simple display
        current = weather_data.get("current_condition", [{}])[0]
        temp = current.get("temp_C", "?")
        condition = current.get("weatherDesc", [{}])[0].get("value", "Unknown")
        console.print(f"üåç Current weather: {get_weather_emoji(condition)} {temp}¬∞C - {condition}")

if __name__ == "__main__":
    main()